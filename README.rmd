---
output:
  md_document:
    variant: markdown_github
---

# Description

This folder was created by first creating a folder on your desktop - copying the adress and then simply running in any instance of R:


```{r, eval = F}
fmxdat::make_project()
```


Next, download https://www.fmx.nfkatzke.com/FMX_data_2021.zip and unzip its contents into the data/ folder in this root.

> NB: add data/ to your gitignore file when creating a repository. Ensure you do not commit the data folder please.

Next, create sub-folders for each question by using, e.g.:

```{r}

# PDF Texevier:
Texevier::create_template(directory = "Questions",
                          template_name = "Question1"
)

# HTML Texevier:
Texevier::create_template_html(directory = "Questions",
                          template_name = "Question2"
)

# PDF Texevier:
Texevier::create_template(directory = "Questions",
                          template_name = "Question3"
)

# HTML Texevier:
Texevier::create_template_html(directory = "Questions",
                          template_name = "Question4"
)

# PDF Texevier:
Texevier::create_template(directory = "Questions",
                          template_name = "Question5"
)

# HTML Texevier:
Texevier::create_template_html(directory = "Questions",
                          template_name = "Question6"
)
```
Question 1

I am tasked to showcase the performance of the AI Implementer fund, comparing it against the benchmark (Capped SWIX) and industry peers (ASISA active managers). Using insights inspired by Bill Sharpe's work, I will illustrate how actively managed funds often struggle to outperform their benchmarks and the AI fund after fees. Employing a rolling period approach, I will highlight key performance metrics, emphasizing the systematic advantages of the AI fund through graphical representations and data-driven insights.

I will start my analysis using the PerfomanceAnalytics package, to make use of this package, it is necessary to spread the data. 
```{r}
AI_xts <- AI_Funds %>% tbl_xts()
BM_xts <- BM %>% select(-Tickers) %>% tbl_xts()
```

Since we also want to compare the AI Fund to managed funds, I created the function mean_A which calculates the returns across all funds for each date. 

```{r}
ASISA_mean <- mean_A(ASISA) 
```

The format of the three datasets now allows to merge them. Furthermore, the columns are renamed for clarity. The merged dataset can then be used to plot a cumulative return chart.

```{r}
merged <- merge.xts(AI_xts, ASISA_mean, BM_xts) %>% na.omit() 
colnames(merged) <- c("AI_Fund", "Managed_Funds", "Benchmark")

chart.CumReturns(merged, legend.loc = 1)
```

The density_plot function creates a density plot to visualize and compare the distribution of rolling returns for multiple funds or data series, including the AI Implementer fund, the benchmark (Capped SWIX), and industry peers (ASISA active managers). It calculates rolling averages over a specified window size (window_size, default is 36) to smooth the data and better reflect trends over time. 

The function converts the rolling averages into a tidy data frame, calculates mean returns for each fund or series, and generates a density plot using ggplot2. The plot displays density curves for each fund, with vertical dashed lines marking the mean returns, and includes titles and labels for clarity.

This visualization helps fulfill the task's goal by demonstrating how the AI fund's return distribution compares to the benchmark and peers, emphasizing return consistency and central tendencies.

```{r}
density_plot(merged, 36)
```

The density_plot_var function creates a density plot to visualize and compare the distribution of rolling variances for multiple funds or data series over a specified window size (window_size, default is 36). It calculates rolling variances to measure the variability of returns over time, which reflects the risk profiles of the AI Implementer fund, the benchmark (Capped SWIX), and industry peers (ASISA active managers).

The function converts the rolling variances into a tidy data frame, computes mean variances for each fund, and generates a density plot using ggplot2. The plot displays density curves for the variances of each fund, with vertical dashed lines indicating the mean variances. Titles, labels, and themes enhance interpretability.

This plot helps illustrate the relative risk levels and variability patterns among the funds, complementing the return-focused analysis. By showcasing the AI fund's risk distribution compared to the benchmark and peers, it provides additional evidence supporting its systematic performance advantage, aligning with the task's goal to highlight the limitations of active management and the strengths of the AI fund.

```{r}
density_plot_var(merged, 36)
```


Calculating the downside deviation and analyzing drawdowns through these functions provides insights into risk management and the behavior of the AI Implementer fund compared to the benchmark (Capped SWIX) and industry peers (ASISA active managers).By calculating downside deviation, we can highlight how the AI fund manages negative outcomes relative to peers. A drawdown chart visually represents the peak-to-trough declines in value over time, offering an intuitive way to assess the severity and duration of losses.

```{r}
DownsideDeviation(merged, 0)
chart.Drawdown(merged, legend.loc = 3)
```

Question 2

This task replicates and expands on a study examining the impact of systematic currency hedging on a 60/40 equity and bond portfolio with a 70/30 local/global split. By comparing rolling volatilities for hedged and unhedged scenarios, I will highlight how the rand's negative correlation with global assets reduces portfolio volatility and enhances returns when left unhedged. Additional figures and tables will support the argument against long-term hedging, emphasizing its tactical, short-term value.

```{r}
Indexes <- read_rds("/Users/x/Downloads/28736907_Fin_Metrics/Questions/Question2/data/Cncy_Hedge_Assets.rds")
ZAR <- read_rds("/Users/x/Downloads/28736907_Fin_Metrics/Questions/Question2/data/Monthly_zar.rds")
```

I will start by calculating the currency returns, which will be needed for the replication of the graphic

```{r}
ZAR_YM <- ZAR %>% mutate(date = format(as.Date(date), "%Y-%m"))
USD_ZAR_returns <- ZAR_YM %>% mutate(Return_cur = value/lag(value) - 1)
```

In a next step the hedged and unhedged returns are calculated. The unhedged returns are calculated by the calculate_returns function, which computes unhedged portfolio returns by converting local indices (42% J433, 28% ALBI) to USD using exchange rates, combining them with global returns (18% MSCI ACWI, 12% Bloomberg Agg), and including USD/ZAR returns for analysis. hedged_returns calculates fully hedged portfolio returns using the same weights but retains local indices directly in ZAR, without exchange rate adjustments. The hedged_returns function calculates hedged portfolio returns using the same weights but keeps local indices in ZAR, excluding currency effects.

```{r}
Return <- calculate_returns(Indexes, ZAR_YM, USD_ZAR_returns)
Return_hedged <- hedged_returns(Indexes)
```

To compute the graph from the study, the unhedged returns and the exchange rate returns are merged to one data frame. This data frame is then used with the create_pot function.
The create_plot function generates a scatter plot with USD-ZAR returns (Return_cur) on the x-axis and global portfolio USD returns (Global_Return) on the y-axis, dividing data into quadrants based on the sign of the returns. It calculates and annotates quadrant percentages, adds descriptive annotations, shades specific areas, and overlays a trend line. Marginal density plots for USD-ZAR and portfolio returns are added on the top and right, respectively, and the plots are combined into a single layout with source information included.

```{r}

data_global <- Return %>% select(date, Global_Return, Return_cur) 
create_plot(data_global)
```

To further examine the performance and volatility differences between hedged and unhedged portfolios, I merge both data frames using the create_merged function; the function uses left_join to merge both sets by date.

```{r}
merged <- create_merged(Return, Return_hedged)

cur_ret <- USD_ZAR_returns %>%
    mutate(date = as.yearmon(date)) %>%
    tbl_xts() %>%
    .["2002-02/"] 
```

We can reuse the functions created in Question 1, which produce density plots for the returns and the variance, both for hedged and unhedged data. This can show the impact of hedging on the volatility and the return.

```{r}
density_plot(merged)
```

```{r}
density_plot_var(merged)
```

To gain further insights on the return differences of hedged and unhedged data the annualized returns will be calculated, this will present the geometric average return. To find out whether the results are consistent and not just driven by outliers, the rolling returns will be plotted.

```{r}
Return.annualized(merged, 12)
```

```{r}
chart.RollingPerformance(merged, legend.loc = 3)
```


Question 3


This Question explores the methodologies and performance differences between the ALSI (J203) and SWIX (J403) indexes. The analysis examines their size-based performance (large, mid, and small caps), sector exposures, and stock concentration trends over time, highlighting key distinctions in return profiles. Additionally, the report evaluates the impact of capping levels (5%, 10%, and uncapped) on both indexes, addressing the JSE's query regarding the application of capping. This study aims to provide actionable insights into how capping influences index characteristics and overall performance.

```{r}
ALSI <- read_rds("/Users/x/Downloads/28736907_Fin_Metrics/Questions/Question3/data/ALSI.rds")
RebDays <- read_rds("/Users/x/Downloads/28736907_Fin_Metrics/Questions/Question3/data/Rebalance_days.rds")
MonZar <- read_rds("/Users/x/Downloads/28736907_Fin_Metrics/Questions/Question3/data/Monthly_zar.rds")
```

To prepare the data for further analyzes, the data will be transformed to a wide format by returns by Tickers. To calculate further Portfolio performance, the weights of the respective Tickers will be extracted using the weight function. The weights function normalizes portfolio weights for each ticker in a dataset by selecting relevant columns, reshaping the data into a wide format, and dividing each value by the row sum to ensure weights in each row sum to 1. It handles missing values by assigning equal weights for rows with all NA values and replaces NAs in numeric columns with 0. The function validates that all row sums are equal to 1 and returns the adjusted weights as a time-series object.

```{r}
rtn <- ALSI %>% select(date, Tickers, Return) %>% spread(Tickers, Return) %>% tbl_xts()
weights_ALSI <- weights(ALSI, "J203")
weights_SWIX <- weights(ALSI, "J403")
```

The reshaping and calculations of the data in the previous step allow to calculate cumaltive returns, this is achieved by the cum_returns function. The cum_returns function calculates and visualizes cumulative returns for two portfolios based on their respective weights. It uses the Safe_Return.portfolio function to compute portfolio returns for the given weight sets, converts the returns to cumulative values, and merges the results into a tidy format. The cumulative returns are plotted as a line chart over time, with separate lines for each portfolio, labeled by their respective weight names (weight_name1 and weight_name2).

```{r}
cum_returns(return_data = rtn, 
                         weights_data1 = weights_ALSI, 
                         weights_data2 = weights_SWIX, 
                         weight_name1 = "ALSI", 
                         weight_name2 = "SWIX")
```

To take a deeper dive into the different Capitalizations, the rolling performance of the different capitalizations will be Analyzed. If big differences can be found, a performance difference can be traced back to that. To achieve this, the function ALSI_index will be applied. The ALSI_index function processes ALSI data to compute the average return for each index by date. It selects relevant columns (date, Return, Index_Name), groups the data by date and Index_Name, calculates the mean return, arranges the data by date, removes missing values, reshapes it into a wide format with Index_Name as columns, and converts the result into a time-series (xts) object.

```{r}
ALSI_index_ret <- ALSI_index(ALSI)
chart.RollingPerformance(ALSI_index_ret, width = 252, legend.loc = 1)
```

To identify differences in the sectors, the two Funds are active are Barchart will be plotted, with the sector share for each fund. This will be done using the sector_exp function. The sector_exp function calculates and visualizes the average sector exposure for the ALSI (J203) and SWIX (J403) methodologies. It groups the data by sector and date, computes the total weight for each methodology, reshapes the data into a long format, and calculates the mean weight for each sector-methodology combination. The results are plotted as a bar chart, showing average weights by sector for both methodologies, with separate bars for ALSI and SWIX.

```{r}
sector_exp(ALSI)
```

Another difference might be found in the Stock concentration, the share the n stocks with highest weight have in total portfolio. This allows conclusion about the diversification. This will be done using the stock_concentration function. The stock_concentration function calculates the contribution of the top n stocks (default 10) to the total weight in the ALSI (J203) and SWIX (J403) indexes for each date. It selects the top n stocks by weight for each index, calculates their combined contribution, merges the results by date, and plots a line chart to compare the stock concentration trends over time for both indexes.

```{r}
stock_concentration(ALSI, 10)
```

To answer the secon part of the question, on what impact capping has at different levels, the Capped_funds function was created. The Capped_funds function calculates and compares capped index values for specified Indexes (J203_cols) and weight cap (W_Cap) values. It filters rebalancing days, selects the top 30 stocks for each Index, normalizes the weights, and applies a proportional capping mechanism to ensure no stock exceeds the specified weight cap. The function computes portfolio returns, cumulative index values, and metadata for each combination of Indexes and weight cap. It outputs a dataset of results and a line plot comparing capped indexes across scenarios over time.

```{r}
Capped_funds(
  ALSI = ALSI, 
  RebDays = RebDays, 
  J203_cols = c("J203"), 
  W_Cap_values = c(0.05, 0.10, 1)
)
```

Question 4



Now add the relevant data for each question into the respective data/ folders in the different Question folders.

Check that your .gitignore file ignores all folders starting with data.


> NB - this README (at the root of your folder) - is what I will be grading. 

> Space out code per question in this README - detailing your steps and thinking.

> Folders in Questions/... should not contain READMEs - I will only be looking at their output (pdf / html).

> THIS README should contain and describe the code you used in your analyses.


Good luck and enjoy the practical!

Nico

